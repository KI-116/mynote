# 时空复杂度
## 时间复杂度$O(n)$, 空间复杂度$O(n)$
```java
// 输入一个整数数组，返回一个新的数组，新数组的每个元素是原数组对应元素的平方
int[] squareArray(int[] nums) {
    int[] res = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        res[i] = nums[i] * nums[i];
    }
    return res;
}
```
申请数组空间及初始化数组也需要时间n
```java
void exampleFn(int n) {
    int[] nums = new int[n];
}
```
# js基本语法
## 变量声明
1. var,let,一般变量
2. 函数声明
```javascript
function add(a, b) {
    return a + b;
}
// 输出 3
console.log(add(1, 2));
```
3. 循环控制
```javascript
// 遍历数组
let arr = [1, 2, 3, 4, 5];
for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}
// 输出 1 2 3 4 5
```
或者
```javascript
arr.forEach((item) => {
    console.log(item);
});
```
4. 条件判断
```javascript
let a = 1;
if (a === 1) {
    console.log("a 等于 1");
} else {
    console.log("a 不等于 1");
}
```
`===、!==` 是值和类型都相等
5. 数据结构

# 数据结构
## 数组
## 链表
## 队列/栈
### 队列
#### API
```cpp
template <typename Q>
class Queue {
    public:
        Queue();
        ~Queue();
        //队尾插入元素
        void push(Q val);
        //队头删除元素
        Q pop();
        //返回队头元素
        Q front();
        //返回队尾元素
        Q back();
        //返回队列大小
        int size();
        //判断队列是否为空
        bool empty();
};
```
#### 队列的列表实现
```cpp
#include <iostream>
#include <list>

template <typename Q>
class LinkedQueue{
    private:
        std::list<Q> list;
    public:
        LinkedQueue();
        ~LinkedQueue();
        //队尾插入元素
        void push(Q val) {
            list.push_back(val);
        }
        //队头删除元素
        Q pop() {
            Q val = list.front();
            list.pop_front();
            return val;
        }
        //返回队头元素
        Q front() {
            return list.front();
        }
        //返回队尾元素
        Q back() {
            return list.back();
        }
        //返回队列大小
        int size() {
            return list.size();
        }
        //判断队列是否为空
        bool empty() {
            return list.empty();
        }
}
```
### 栈
#### API
```cpp
template <typename S>
class Stack{
    public:
        Stack();
        ~Stack();
        //栈顶插入元素
        void push(S val);
        //栈顶删除元素
        S pop();
        //返回栈顶元素
        S top();
        //返回栈大小
        int size();
        //判断栈是否为空
        bool empty();
};
```
#### 栈的列表实现
调用双链表实现
```cpp
#include <iostream>
#include <list>

template <typename S>
class LinkedStack {
    private:
        std::list<S> list;
    public:
        LinkedStack();
        ~LinkedStack();
        //栈顶插入元素
        void push(S val) {
            list.push_back(val);
        }
        //栈顶删除元素
        S pop() {
            S val = list.back();
            list.pop_back();
            return val;
        }
        //返回栈顶元素
        S top() {
            return list.back();
        }
        //返回栈大小
        int size() {
            return list.size();
        }
}

int main() {
    LinkedStack<int> stack;
    stack.push(1);
    stack.push(2);
    stack.push(3);
    while (!stack.empty()) {
        std::cout << stack.pop() << std::endl;
    }
    return 0;
}
```

